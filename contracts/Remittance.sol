pragma solidity >=0.4.21 <0.6.0;

import './Stoppable.sol';
import './SafeMath.sol';

contract Remittance is Stoppable {
    // library
    using SafeMath for uint;

    // ENUM
    // order status
    // Not_Set: null
    // Available: ready to send out
    // Cancelled: refunded to the owner, cancel order
    // Claimed: claimed by receiver
    enum OrderStatus {Not_Set, Available, Claimed, Cancelled}

    // STRUCT
    // order
    struct Order {
        bytes32 puzzle;
        uint256 amount;
        uint256 expiredBlock;
        address creator;
        address receiver;
        OrderStatus status;
    }

    // PRIVATE VARIABLES
    // maximum number of blocks
    // limit to how far in the future the deadline can be 
    uint256 private _maxBlockExpiration;
    // list of orders by order Id
    // Order Id is generated by keccak256 of puzzle
    mapping(bytes32 => Order) _orderOf;

    // EVENTS
    // new order event
    event NewOrderEvent(
        bytes32 indexed orderId,
        address indexed sender, // as creator
        uint256 amount,
        uint256 expiredBlock
    );
    // claim order event
    event ClaimOrderEvent(
        bytes32 indexed orderId,
        address indexed sender, // as receiver
        uint256 amount,
        bytes32 password1,
        bytes32 password2
    );
    // cancel order event
    event CancelOrderEvent(
        bytes32 indexed orderId,
        address indexed sender // as creator
    );
    // set max block expiration
    event SetMaxBlockExpirationEvent(
        address indexed sender,
        uint256 newValue
    );

    // MODIFIER
    // block expiration
    modifier blockExpirationValidOnly(
        uint256 blockExpiration
    )
    {
        require(blockExpiration <= _maxBlockExpiration,
            "Block Expiration must less than max block expiration"
        );
        _;
    }

    // constructor
    constructor(bool isRunning, uint256 maxBlockExpiration)
        public
        Stoppable(isRunning)
    {
        _maxBlockExpiration = maxBlockExpiration;
    }

    // PUBLIC METHODS
    // GETTERs
    // max block expiration
    function maxBlockExpiration() public view returns (uint256) {
        return _maxBlockExpiration;
    }
    // Get order with
    // valid order id
    function getOrder(bytes32 orderId)
        public
        view
        returns(
            address creator,
            bytes32 puzzle,
            uint256 amount,
            uint256 expiredBlock,
            OrderStatus status
        )
    {
        Order memory order = _orderOf[orderId];

        // require order
        require(isOrderExist(order), "Order not found");

        // return
        creator = order.creator;
        puzzle = order.puzzle;
        amount = order.amount;
        expiredBlock = order.expiredBlock;
        status = order.status;
    }

    // SETTERs
    // set max deadline block
    function setMaxBlockExpiration(uint256 max)
        public
        ownerOnly
    {
        require(max > 0, "Value must greater than zero");
        _maxBlockExpiration = max;
        emit SetMaxBlockExpirationEvent(msg.sender, max);
    }

    // Create order with
    // valid puzzle
    // value >0
    // deadline < maxDeadline
    function createOrder(
        address receiver,
        bytes32 puzzle,
        uint256 blockExpiration
    )
        public
        payable
        runningOnly
        blockExpirationValidOnly(blockExpiration)
        returns (bytes32 orderId)
    {
        // validate inputs
        require(puzzle != 0, "Invalid Puzzle");
        require(msg.value > 0, "Ether amount must greater than zero");

        // generate order id
        orderId = generateOrderId(puzzle);
        // get order by id
        Order memory existOrder = _orderOf[orderId];
        // order must not exist
        // if orderId exist then puzzle exist
        // avoid puzzle reusage
        require(!isOrderExist(existOrder), "Puzzle already exist");

        // CREATE
        // expired Block
        uint256 expiredBlock = block.number.add(blockExpiration);

        //create new order
        Order memory newOrder = Order({
                puzzle: puzzle,
                amount: msg.value,
                expiredBlock: expiredBlock,
                creator: msg.sender,
                receiver: receiver,
                status: OrderStatus.Available
            });

        // save order
        _orderOf[orderId] = newOrder;

        // event
        emit NewOrderEvent(orderId, msg.sender, msg.value, expiredBlock);
    }

    // Claim order with
    // valid puzzle
    // status = Available
    // not expire
    function claimOrder(
        bytes32 password1,
        bytes32 password2
    )
        public
        runningOnly
    {
        // validate inputs
        require(password1 != 0 && password2 != 0,
            "Passwords are required"
        );
        // generate input puzzle
        bytes32 inputPuzzle = generatePuzzle(password1, password2);
        // get order id
        bytes32 orderId = generateOrderId(inputPuzzle);

        // get order
        Order memory order = _orderOf[orderId];

        // order must exist
        require(isOrderExist(order), "Order not found");
        
        // sender must be receiver
        require(order.receiver == msg.sender,
            "Only order receiver can claim"
        );

        // must available
        require(order.status == OrderStatus.Available,
            "Order not available"
        );

        // validate puzzle
        require(order.puzzle == inputPuzzle,
            "Unauthorized"
        );

        // set status
        _orderOf[orderId].status = OrderStatus.Claimed;

        // event
        emit ClaimOrderEvent(orderId, msg.sender, order.amount, password1, password2);

        // transfer
        msg.sender.transfer(order.amount);
    }

    // Cancel order with
    // valid order Id
    // status = Available
    // right owner
    function cancelOrder(bytes32 orderId)
        public
        runningOnly
    {
        // get order
        Order memory order = _orderOf[orderId];
        // order must exist
        require(isOrderExist(order), "Order not found");

        // creator only
        require(order.creator == msg.sender,
            "Only order creator to cancel order"
        );

        // must available
        require(order.status == OrderStatus.Available,
            "Only cancel available order"
        );
        // must expired
        require(block.number > order.expiredBlock,
            "Only cancel expired order"
        );

        // set status
        _orderOf[orderId].status = OrderStatus.Cancelled;

        // event
        emit CancelOrderEvent(orderId, msg.sender);
        // refund
        msg.sender.transfer(order.amount);
    }

    // generate puzzle
    function generatePuzzle(
        bytes32 password1,
        bytes32 password2
    )
        public
        pure
        returns(bytes32 puzzle)
    {
        puzzle = keccak256(
            abi.encodePacked(password1, password2)
        );
    }
    
    // generate order id
    // from puzzle
    function generateOrderId(
        bytes32 puzzle
    )
        public
        pure
        returns (bytes32 orderId)
    {
        orderId = keccak256(abi.encodePacked(puzzle));
    }

    // PRIVATE METHODS
    // order valid
    // return if order is empty obj
    function isOrderExist(
        Order memory order
    )
        private
        pure
        returns(bool valid)
    {
        valid = order.status != OrderStatus.Not_Set;
    }
    
}